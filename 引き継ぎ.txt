


（引継ぎ）
以下は前任からの引継ぎ資料です。少々仕様に疎い部分があったので、こちらは参考にお願いします。


NDSimulator 開発引き継ぎ資料

1. プロジェクト構造とファイル間の関連
本シミュレーターは、肥大化を防ぐためにクラス機能をMixin（ミキシン）を用いて分割・構成している。

メイン実行・管理

main.py: エントリーポイント。キャラクター生成、JSON読み込み、シミュレーター初期化、実行、結果表示を行う。

models.py: データクラス定義（Skill, DamageProfile, WeaponConfig）。

buff_manager.py: バフおよびスタックの管理クラス。

重要修正: add_buff に stack_amount 引数を追加し、一度に複数スタック増加させる機能が必要。

シミュレーターエンジン (NikkeSimulator クラス) engine.py で以下のMixinを継承して統合している。

engine.py: メインループ (tick)、初期化、ログ出力、全体進行管理。

engine_skills.py (SkillEngineMixin): スキル効果の判定と適用ロジック (apply_skill, check_target_condition)。

実装済み効果: damage, buff, stack_buff, heal, refill_ammo, set_current_ammo, delayed_action, weapon_change, cooldown_reduction 等。

engine_burst.py (BurstEngineMixin): バースト状態の遷移 (tick_burst_state)、クールダウン管理。

処理順序: バースト発動時は「スキル発動(タグ付与) on_use_burst_skill」→「バースト突入トリガー on_burst_enter」の順で処理すること（条件判定のため）。

キャラクター (Character クラス) character.py で以下のMixinを継承して統合している。

character.py: 基本属性の保持、初期化。

character_stats.py (CharacterStatsMixin): ステータス計算、ダメージ計算 (calculate_strict_damage)、フレーム短縮計算。

character_skill.py (CharacterSkillMixin): スキル発動トリガーの判定ロジック (process_trigger)。

character_action.py (CharacterActionMixin): 射撃、リロード、弾薬管理、状態遷移 (tick_action)。

2. ダメージ計算・スキル処理における重要ロジック
以下のロジックはデバッグを経て確定した仕様であるため、勝手に変更してはならない。

トリガー判定ロジック (process_trigger)

回数累積型 (pellet_hit, critical_hit):

単純な閾値超え判定ではなく、(現在値 // 条件値) - (前回値 // 条件値) > 0 というロジックで判定する。

これにより、1フレームに条件を複数回満たした場合（例：散弾で一気にヒット数が増えた、バーストで多数のクリティカルが出た）、その回数分だけスキルを発動させる。

スタック数監視 (stack_count):

毎フレーム監視すると無限ループするため、バフが付与されてスタックが増加した瞬間 (apply_skill 内) にのみ判定を行う。

判定には delta (増加量) を用い、閾値をまたいだ場合のみ発動する。

回復時 (on_receive_heal):

効果タイプ heal が実行された時にのみトリガーされる。

スキル効果の実装詳細 (apply_skill)

heal: ログ出力を行い、ターゲットの on_receive_heal トリガーを引く。

refill_ammo: 最大装弾数の割合(%)で弾丸を即時回復する。

set_current_ammo: 残弾数を特定の値（例: 0）に強制変更する。

delayed_action: 指定秒数(duration)経過後のフレームに、指定された sub_effect を予約実行する。

ダメージ計算:

scale_by_target_stack: ターゲット（敵）の指定デバフスタック数に応じてダメージ倍率を乗算する機能。

3. これまでの修正・要望履歴（考慮すべき事情）
DoT（持続ダメージ）:

stack_dot および dot 効果タイプの実装。毎秒 (frame % 60 == 0) 計算しログ出力する。

バースト仕様:

フルバースト終了後、次のバースト受付開始までに「バースト溜め時間（デフォルト5秒）」の待機時間 (GEN 状態) を設ける。この時間はCT短縮の影響を受けない。

JSONデータの扱い:

warmup_table (MG用) は配列の配列 [[frame, interval], ...] 形式と、辞書リスト [{"start":.., "interval":..}] 形式の混在に注意し、安全に読み込むこと。

shot_duration: バフの持続を「発射回数」で制限するパラメータ。

コード生成時の制約:

既存ロジックの改変禁止: ファイル分割や機能追加の際、動作確認済みの既存ロジック（特にダメージ計算式）を勝手に書き換えないこと。

全文出力: 修正時は、基本的にパッチ形式で出力すること。修正箇所が1メソッド内で複数ある場合はメソッドごと出力すること。


4. 最新の仕様変更・注意点（追加事項）

JSONデータのプリプロセス要件 (value_list)

JSON内のスキル定義において、レベルごとの数値を value_list (配列) で持たせている場合がある。

シミュレーターエンジン (engine_skills.py) は配列を解釈せず、単一の value キーのみを参照する。

したがって、main.py 等のロード処理段階で、指定されたスキルレベルに対応する値を value_list から抽出し、value キーとして再設定してからエンジンに渡す処理が必須である。

タグ判定のスコープ (condition vs target_condition)

skill.condition 内の has_tag / not_has_tag は、「敵全体のデバフ状況 (Shared Enemy Debuffs)」 を判定する仕様となっている。

味方（または自分自身）に付与されたタグ（例：アルカナの「運命の輪」状態など）を判定条件とする場合は、必ず target_condition 内に has_tag を記述すること。

condition: 敵の状態、またはグローバルな状況の判定

target_condition: スキル対象（Self含む）の状態判定

MG武器データの正規化

character_action.py のロジックは、MGの warmup_table が「辞書のリスト [{'start':.., 'interval':..}]」であることを前提としている。

元データが「配列の配列 [[frame, interval], ...]」である場合は、models.py (WeaponConfig) の初期化時などで必ず辞書形式に変換（正規化）すること。これを怠ると実行時エラーになる。

リロード・チャージ時間の計算式変更

以前の除算型ロジック（reload_speed_fixed_value による割り算）は廃止された。

現在は「割合短縮（乗算）」と「固定値短縮（減算）」を組み合わせた calculate_reduced_frame メソッドを使用する。

攻撃速度（Attack Speed）には固定値短縮（減算）は適用されない仕様とした。

5. 直近の仕様変更・実装ルール（最新改修分）

【JSONパラメータの優先順位変更 (_list の扱い)】
main.py の読み込み処理において、kwargs 内に `_list` で終わるキー（例: duration_list）が存在する場合、
レベル計算後の値が、既存の単一キー（例: duration）よりも**優先して上書き**される仕様に変更済み。
これにより、従来は固定値しか設定できなかった「効果時間 (duration)」などもスキルレベルごとの変動に対応可能。

【特殊スキルダメージ枠の実装】
一部の特殊なダメージ計算に対応するため、既存のダメージ計算式とは独立した乗算枠を追加。
1. ダメージ発生側（JSON）: `profile` に `"is_special_skill_damage": true` を指定。
2. バフ付与側（JSON）: `buff_type` に `"special_skill_dmg_buff"` を指定。
計算式: ... × (1 + special_skill_dmg_buff) ... となり、他のバフ枠とは乗算の関係になる。

【scale_by_caster_stats の参照ステータス変更】
発動者のステータスを参照してバフ量を決定する `scale_by_caster_stats: true` の挙動を変更。

・変更前: デフォルトで「現在のバフ込みステータス (current)」を参照していた。
・変更後: デフォルトで「**基礎ステータス (base)**」を参照するように変更。

※これにより、循環参照や二重バフのリスクを低減している。
※もし旧仕様のように「バフ込みの最終ステータス」を参照したい場合は、
  JSONの kwargs に `"stat_type": "finally"` を明示的に記述すること。

  6. アイン実装に伴う新規トリガー・効果の仕様（最新機能）

複雑な周期管理やスタック操作を持つキャラクター（アイン等）に対応するため、以下の機能を実装済み。

【新規効果: set_stack】
特定のバフスタック数を、増減ではなく「指定した値」に強制上書きする効果。
使用例: 開幕やバースト発動時にスタック数をリセット・固定する場合。
記述: 
  "effect_type": "set_stack",
  "kwargs": { "stack_name": "...", "value": 6 }

【新規トリガー: variable_interval】
現在の「スタック数」に応じて、発動間隔（フレーム数）が動的に変化するトリガー。
engine.py の tick メソッド内で毎フレーム判定が行われる。
記述:
  "trigger_type": "variable_interval",
  "kwargs": { 
    "stack_name": "...", 
    "intervals": { "6": 18, "4": 180, ... }  // "スタック数": 間隔フレーム
  }

【新規トリガー: interval_after_burst_end】
「自身が発動したバースト（フルバースト）の終了時刻」を0秒地点として、一定時間ごとに発動するトリガー。
通常の time_interval（戦闘開始時起点）とは異なり、バースト周期に依存したギミック（自然減少など）に使用する。
注意点:
  - Characterクラスに last_burst_end_frame 変数を追加し、engine_burst.py でフルバースト終了時に更新している。
  - バーストIIIを担当していない（フルバーストを発動させていない）場合はトリガーされない。
7. JSON読み込みロジックの刷新（再帰処理・ネスト対応）

スキルデータ読み込み時（main.py）の `_list` パラメータ展開処理を強化。

【変更内容】
従来は `kwargs` 直下のキーのみをチェックしていたが、**再帰的に辞書内部を走査**するように変更。
これにより、`weapon_data` のような入れ子構造内のパラメータや、任意の階層にある `stack_amount` などもスキルレベルに応じて変動させることが可能になった。

【仕様・注意点】
1. **ネスト対応**:
   `kwargs` -> `weapon_data` -> `multiplier_list` のような記述が可能。
   これにより、バーストスキルで武器を持ち替えるキャラ（K、スノーホワイト等）の「武器倍率のレベル変動」を正確に再現できる。

2. **上書きルール（優先順位）**:
   同名の固定値キー（例: `multiplier`）と変動値リスト（例: `multiplier_list`）が両方存在する場合、
   **常にリストから算出された値（レベル依存値）で上書き**する仕様とした。
   （以前の `if key not in ...` チェックは撤廃済み）

【JSON記述例】
"kwargs": {
  "stack_amount_list": [10, 11, ...],  // 直下もOK
  "weapon_data": {
    "multiplier": 1.0,                 // デフォルト値（万が一リストがない場合用）
    "multiplier_list": [1.5, 1.6, ...] // こちらが優先適用される
  }
}

【JSON記述時の注意点：kwargs の必須性】
スキル効果のパラメータ（value, duration, buff_type, および各種 _list）は、
必ず `kwargs` ディクショナリの中に記述する必要がある。

特に `cumulative_stages` の内部ステージを記述する際、
`effect_type` と同列に `value_list` などを書いてしまうミスが発生しやすい。
この場合、main.py の再帰読み込み処理の対象外となり、
レベル変動が適用されず（デフォルト値または0として）処理されてしまうため注意すること。

NG例:
{ "effect_type": "buff", "value_list": [...] }

OK例:
{ "effect_type": "buff", "kwargs": { "value_list": [...] } }

8. ターゲット指定と条件判定の厳密化（最新改修）

【cumulative_stages 内のターゲット優先度変更】
バーストスキル（親スキル）のターゲットと、その内部ステージ（個別のバフなど）のターゲットが異なるケースに対応。
・仕様: ステージ定義内に `target` 指定がある場合、親スキルのターゲットよりも優先して適用される。
・用途: 「敵にダメージを与える（Target: Enemy）」バーストスキルの中で、「味方にバフを撒く（Target: Allies）」効果を混在させる場合（D：キラーワイフ等）。

【フルチャージ攻撃トリガー (full_charge_count) の実装】
SR/RL/CHARGE 武器において、フルチャージ攻撃を行った回数をトリガーとする機能を実装。
・仕様: 
  - Characterクラスに `cumulative_full_charge_count` を追加。
  - 現状のシミュレーターでは SR/RL は常にフルチャージ発射扱いとなるため、実質的に射撃時にカウントアップされる。
  - 将来的に「速射（非フルチャージ）」を実装する場合は、判定ロジックの分岐が必要。
・記述例: `"trigger_type": "full_charge_count", "trigger_value": 5`

【部位破壊トリガー (part_break) の挙動修正】
cumulative_stages 内に含まれる `trigger_type: "part_break"` のステージについて、シミュレーター設定（part_break_mode）を正しく参照するように修正。
・変更前: 無条件で発動していた。
・変更後: シミュレーターの `part_break_mode` が False の場合、該当ステージはスキップされる。